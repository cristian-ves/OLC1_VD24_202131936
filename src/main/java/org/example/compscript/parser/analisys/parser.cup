// Header Java code
package org.example.compscript.parser.analisys;

import java_cup.runtime.*;
import java.util.LinkedList;
import org.example.compscript.parser.abstract_.Instruction;
import org.example.compscript.parser.symbol.*;
import org.example.compscript.parser.symbol.Symbol;

// Instructions
import org.example.compscript.parser.instructions.Print;

// Expressions
import org.example.compscript.parser.expresions.Native;
import org.example.compscript.parser.expresions.operators.relational.*;
import org.example.compscript.parser.expresions.operators.arithmetic.*;


// Class name
parser code {:

    Lexer lex;
    Parser(Lexer lex){this.lex = lex;}

    public void syntax_error(Symbol s){}

    public void unrecovered_syntax_error (Symbol s){}

:}

action code {:
:}

// Terminals
terminal String SINGLE_LINE_COMMENT, BLOCK_COMMENT;
terminal String COLON;
terminal String CONST, LET, CAST, AS, IF, ELSE, MATCH, DEFAULT, WHILE, FOR, DO, BREAK, CONTINUE;
terminal String OR, AND, NOT;
terminal String BRA_START, BRA_END, INCREMENT, DECREASE, ID;

terminal String WHOLE, STRING, DOUBLE, BOOLEAN, CHAR;
terminal END, CONSOLE, DOT, LOG;
terminal PAR_START, PAR_END, PLUS, MINUS, UMINUS, EQUALS, MULTIPLICATION, DIVISION, POWER, ROOT, MODULO;
terminal EQUALS_TO, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL_THAN, GREATER_EQUAL_THAN;

// Non-terminals
// non terminal LinkedList<Instruction> s, INSTRUCTIONS;
// non terminal Instruction INSTRUCTION, PRINT;
// non terminal Instruction EXPRESSION;
nonterminal LinkedList<Instruction> S, INSTRUCTIONS;
nonterminal Instruction INSTRUCTION, PRINT;
nonterminal Instruction EXPRESSION;

// precedences
precedence left EQUALS_TO, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL_THAN, GREATER_EQUAL_THAN;
precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVISION, MODULO;
precedence nonassoc POWER, ROOT;
precedence right UMINUS;

// Initial state
start with S;

// Productions
S ::= INSTRUCTIONS:a  {: RESULT = a; :}
;

INSTRUCTIONS ::= INSTRUCTIONS:a INSTRUCTION:b {: RESULT = a; RESULT.add(b); :}
               | INSTRUCTION:a                {: RESULT = new LinkedList<Instruction>(); RESULT.add(a); :}
;

INSTRUCTION ::= PRINT:a END {: RESULT = a; :}
;

PRINT ::= CONSOLE DOT LOG PAR_START EXPRESSION:a PAR_END {: RESULT = new Print(a, aleft, aright); :}
;

EXPRESSION ::= MINUS EXPRESSION:a {: RESULT = new UnitaryNegation(a, aleft, aright); :} %prec UMINUS
            | EXPRESSION:a PLUS EXPRESSION:b {: RESULT = new Addition(a, b, aleft, aright); :}
            | EXPRESSION:a MINUS EXPRESSION:b {: RESULT = new Substraction(a, b, aleft, aright); :}
            | EXPRESSION:a MULTIPLICATION EXPRESSION:b {: RESULT = new Multiplication(a, b, aleft, aright); :}
            | EXPRESSION:a DIVISION EXPRESSION:b {: RESULT = new Division(a, b, aleft, aright); :}
            | EXPRESSION:a POWER EXPRESSION:b {: RESULT = new Power(a, b, aleft, aright); :}
            | EXPRESSION:a ROOT EXPRESSION:b {: RESULT = new Root(a, b, aleft, aright); :}
            | EXPRESSION:a MODULO EXPRESSION:b {: RESULT = new Modulo(a, b, aleft, aright); :}
            | EXPRESSION:a EQUALS_TO EXPRESSION:b {: RESULT = new EqualsTo(a, b, aleft, aright); :}
            | EXPRESSION:a NOT_EQUAL EXPRESSION:b {: RESULT = new NotEqualsTo(a, b, aleft, aright); :}
            | EXPRESSION:a LESS_THAN EXPRESSION:b {: RESULT = new LessThan(a, b, aleft, aright); :}
            | EXPRESSION:a GREATER_THAN EXPRESSION:b {: RESULT = new GreaterThan(a, b, aleft, aright); :}
            | EXPRESSION:a LESS_EQUAL_THAN EXPRESSION:b {: RESULT = new LessEqualsThan(a, b, aleft, aright); :}
            | EXPRESSION:a GREATER_EQUAL_THAN EXPRESSION:b {: RESULT = new GreaterEqualsThan(a, b, aleft, aright); :}
            | WHOLE:a                  {: RESULT = new Native(Integer.parseInt(a),new Type(dataType.WHOLE), aleft, aright); :}
            | STRING:a {: RESULT = new Native(a, new Type(dataType.STRING), aleft, aright); :}
            | DOUBLE:a                 {: RESULT = new Native(new Double(a),new Type(dataType.DOUBLE), aleft, aright); :}
            | BOOLEAN:a {: RESULT = new Native(Boolean.parseBoolean(a), new Type(dataType.BOOLEAN), aleft, aright); :}
            | CHAR:a {: RESULT = new Native(a.charAt(0), new Type(dataType.CHAR), aleft, aright); :}
            | PAR_START EXPRESSION:a PAR_END {: RESULT = a; :}
;