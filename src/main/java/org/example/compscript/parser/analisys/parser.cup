// Header Java code
package org.example.compscript.parser.analisys;

import java_cup.runtime.*;
import java.util.LinkedList;
import org.example.compscript.parser.abstract_.Instruction;
import org.example.compscript.parser.symbol.*;

// Instructions
import org.example.compscript.parser.instructions.Print;
import org.example.compscript.parser.instructions.Declaration;

// Expressions
import org.example.compscript.parser.expresions.Native;
import org.example.compscript.parser.expresions.operators.relational.*;
import org.example.compscript.parser.expresions.operators.arithmetic.*;
import org.example.compscript.parser.expresions.operators.logic.*;
import org.example.compscript.parser.exceptions.*;
import org.example.compscript.parser.expresions.cast.Cast;
import org.example.compscript.parser.expresions.variables.Access;


// Class name
parser code {:

    Lexer lex;
    Parser(Lexer lex){this.lex = lex;}

    public LinkedList<CompError> sintacticErrors = new LinkedList<>();

    public void syntax_error(Symbol s){
        sintacticErrors.add(new CompError(
            ErrorType.SINTACTICR, 
            "Component did not expected " + s.value,
            s.left,
            s.right
        ));
    }

    public void unrecovered_syntax_error (Symbol s){
        sintacticErrors.add(new CompError(
            ErrorType.SINTACTICU, 
            "Component did not expected " + s.value,
            s.left,
            s.right
        ));
    }

:}

action code {:
:}

// Terminals
terminal String IF, ELSE, MATCH, DEFAULT, WHILE, FOR, DO, BREAK, CONTINUE;
terminal String BRA_START, BRA_END, INCREMENT, DECREASE;

terminal String WHOLE, STRING, DOUBLE, BOOLEAN, CHAR, ID;
terminal END, COLON, CONSOLE, DOT, LOG, CAST, AS, CONST, LET;
terminal INT_RW, DOUBLE_RW, CHAR_RW, BOOL_RW, STRING_RW;
terminal PAR_START, PAR_END, PLUS, MINUS, UMINUS, EQUALS, MULTIPLICATION, DIVISION, POWER, ROOT, MODULO;
terminal EQUALS_TO, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL_THAN, GREATER_EQUAL_THAN;
terminal OR, AND, NOT;

// Non-terminals
nonterminal LinkedList<Instruction> S, INSTRUCTIONS;
nonterminal Instruction INSTRUCTION, PRINT, DECLARATION;
nonterminal Instruction EXPRESSION;
nonterminal Type TYPE_RW;
nonterminal String MUTABILITY;

// precedences
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left EQUALS_TO, NOT_EQUAL, LESS_THAN, GREATER_THAN, LESS_EQUAL_THAN, GREATER_EQUAL_THAN;
precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVISION, MODULO;
precedence nonassoc POWER, ROOT;
precedence right UMINUS;

// Initial state
start with S;

// Productions
S ::= INSTRUCTIONS:a  {: RESULT = a; :}
;

INSTRUCTIONS ::= INSTRUCTIONS:a INSTRUCTION:b {: RESULT = a; RESULT.add(b); :}
               | INSTRUCTION:a                {: RESULT = new LinkedList<Instruction>(); RESULT.add(a); :}
;

INSTRUCTION ::= PRINT:a END {: RESULT = a; :}
            | DECLARATION:a END {: RESULT = a; :}
            | error END {: RESULT = null; :}
;

PRINT ::= CONSOLE DOT LOG PAR_START EXPRESSION:a PAR_END {: RESULT = new Print(a, aleft, aright); :}
;

MUTABILITY ::= CONST {: RESULT = "false"; :}
            | LET {: RESULT = "true"; :}
;

TYPE_RW ::= INT_RW {: RESULT = new Type(dataType.WHOLE); :}
         | DOUBLE_RW {: RESULT = new Type(dataType.DOUBLE); :}
         | BOOL_RW {: RESULT = new Type(dataType.BOOLEAN); :}
         | CHAR_RW {: RESULT = new Type(dataType.CHAR); :}
         | STRING_RW {: RESULT = new Type(dataType.STRING); :}
;

DECLARATION ::= MUTABILITY:a ID:b COLON TYPE_RW:c EQUALS EXPRESSION:d {: RESULT = new Declaration(a, b, c, d, aleft, aright); :}
            | MUTABILITY:a ID:b COLON TYPE_RW:c {: RESULT = new Declaration(a, b, c, aleft, aright); :}
;

EXPRESSION ::= MINUS EXPRESSION:a {: RESULT = new UnitaryNegation(a, aleft, aright); :} %prec UMINUS
            | EXPRESSION:a PLUS EXPRESSION:b {: RESULT = new Addition(a, b, aleft, aright); :}
            | EXPRESSION:a MINUS EXPRESSION:b {: RESULT = new Substraction(a, b, aleft, aright); :}
            | EXPRESSION:a MULTIPLICATION EXPRESSION:b {: RESULT = new Multiplication(a, b, aleft, aright); :}
            | EXPRESSION:a DIVISION EXPRESSION:b {: RESULT = new Division(a, b, aleft, aright); :}
            | EXPRESSION:a POWER EXPRESSION:b {: RESULT = new Power(a, b, aleft, aright); :}
            | EXPRESSION:a ROOT EXPRESSION:b {: RESULT = new Root(a, b, aleft, aright); :}
            | EXPRESSION:a MODULO EXPRESSION:b {: RESULT = new Modulo(a, b, aleft, aright); :}
            | EXPRESSION:a EQUALS_TO EXPRESSION:b {: RESULT = new EqualsTo(a, b, aleft, aright); :}
            | EXPRESSION:a NOT_EQUAL EXPRESSION:b {: RESULT = new NotEqualsTo(a, b, aleft, aright); :}
            | EXPRESSION:a LESS_THAN EXPRESSION:b {: RESULT = new LessThan(a, b, aleft, aright); :}
            | EXPRESSION:a GREATER_THAN EXPRESSION:b {: RESULT = new GreaterThan(a, b, aleft, aright); :}
            | EXPRESSION:a LESS_EQUAL_THAN EXPRESSION:b {: RESULT = new LessEqualsThan(a, b, aleft, aright); :}
            | EXPRESSION:a GREATER_EQUAL_THAN EXPRESSION:b {: RESULT = new GreaterEqualsThan(a, b, aleft, aright); :}
            | EXPRESSION:a AND EXPRESSION:b {: RESULT = new And(a, b, aleft, aright); :}
            | EXPRESSION:a OR EXPRESSION:b {: RESULT = new Or(a, b, aleft, aright); :}
            | NOT EXPRESSION:a {: RESULT = new Not(a, aleft, aright); :}
            | WHOLE:a                  {: RESULT = new Native(Integer.parseInt(a),new Type(dataType.WHOLE), aleft, aright); :}
            | STRING:a {: RESULT = new Native(a, new Type(dataType.STRING), aleft, aright); :}
            | DOUBLE:a                 {: RESULT = new Native(new Double(a),new Type(dataType.DOUBLE), aleft, aright); :}
            | BOOLEAN:a {: RESULT = new Native(Boolean.parseBoolean(a), new Type(dataType.BOOLEAN), aleft, aright); :}
            | CHAR:a {: RESULT = new Native(a.charAt(0), new Type(dataType.CHAR), aleft, aright); :}
            | ID:a {: RESULT = new Access(a, aleft, aright); :}
            | CAST PAR_START EXPRESSION:a AS TYPE_RW:b PAR_END {: RESULT = new Cast(a, b, aleft, aright); :}
            | PAR_START EXPRESSION:a PAR_END {: RESULT = a; :}
;